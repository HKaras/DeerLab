.. _dipolarkernel:

*********************
:mod:`dipolarkernel`
*********************

Computes the dipolar kernel matrix ``K`` that transforms a distance distribution ``P`` to a time-domain dipolar signal ``D`` via ``D = K*P``.

-------------------------------


Syntax
=========================================

::

    K = dipolarkernel(t,r)
    K = dipolarkernel(t,r,lambda)
    K = dipolarkernel(t,r,lambdaT0)
    K = dipolarkernel(t,r,lambda,B)
    K = dipolarkernel(t,r,lambdaT0,B)
    K = dipolarkernel(___,'Property',Value)


Parameters
    *   ``t``        - Time axis vector (*N*-element array), in microseconds
    *   ``r``        - Distance axis vector (*M*-element array), in nanometers
    *   ``lambda``   - Modulation depth (scalar)
    *   ``lambdaT0`` - Array of modulation depths and refocusing times (*mx2* array)
    *   ``B``        - Background, either vector of values (*N*-element array) or function handle
Returns
    *  ``K`` - Dipolar kernel matrix (*NxM* array)

-------------------------------


Description
=========================================

.. code-block:: matlab

   K = dipolarkernel(t,r)

Computes the kernel matrix ``K`` for the time axis ``t`` (in microseconds) and distance axis ``r`` (in nanometers). ``K`` transforms a distance distribution `\mathbf{P}` to a dipolar evolution function `\mathbf{D}`

    .. math:: \mathbf{K}\mathbf{P}  = \mathbf{D}

The dipolar kernel is normalized by `\Delta r`, such that it returns a dipolar signal with amplitude 1 at time zero for a normalized distance distribution (i.e. ``sum(P)*dr==1``). By default, all distributions ``P`` generated by DeerLab model distribution functions are already normalized.


-----------------------------


.. code-block:: matlab

    K = dipolarkernel(t,r,lambda)

If the modulation depth ``lambda`` is specified, then it is included into the kernel matrix. ``K`` then describes the transformation from the distance distribution to the form factor `\mathbf{F}` given by


    .. math:: \mathbf{K}\mathbf{P}  = \mathbf{F} = (1-\lambda) + \lambda \mathbf{D}


-----------------------------


.. code-block:: matlab

    K = dipolarkernel(t,r,lambda,B)

If the background ``B`` and modulation depth ``lambda`` are specified, then both are included into the kernel matrix. ``B`` can be either an array with the precalculated background decay, or a function handle with a background model. ``K`` describes the transformation from the distance distribution to the dipolar signal `\mathbf{V}` given by

    .. math:: \mathbf{K}\mathbf{P}  = \mathbf{V} = [(1-\lambda) + \lambda \mathbf{D} ]\mathbf{B}


-------------------------------


.. code-block:: matlab

    K = dipolarkernel(t,r,lambdaT0)
    K = dipolarkernel(t,r,lambdaT0,B)

For a multi-pathway DEER signal (e.g, 4-pulse DEER with 2+1 contribution; 5-pulse DEER with 4-pulse DEER residual signal), ``lambdaT0`` contains a list of modulation depths (amplitudes) and refocusing times (in microseconds) for all modulated pathway signals. Each row of ``lambdaT0`` needs two values: one amplitude and one time. The unmodulated amplitudes is calculated such that the sum over all amplitudes equals 1.

.. code-block:: matlab

    lambda = [0.7 0.2];   % modulation depths of two pathways
    T0 = [0 4];           % corresponding refocusing times, in microseconds
    lambdaT0 = [lambda(:) T0(:)];
    K = dipolarsignal(t,r,lambdaT0);



Additional Settings
=========================================


Additional settings can be specified via name-value pairs. All property names are case insensitive and the property-value pairs can be passed in any order after the required input arguments have been passed..

.. code-block:: matlab

    K = dipolarkernel(___,'Property1',Value1,'Property2',Value2,___)

- ``'ExcitationBandwidth'`` - Excitation bandwith of the pulses in **MHz**. 
    Use this to include limited excitation bandwidth of the experimental pulses. If not specified, infinite excitation bandwidth is assumed. The compensation for a given excitation bandwidth :math:`\Delta\omega` is taken into account by the approximation

    .. math:: K_{\Delta\omega}(t,r)  = \mathrm{exp}\left(-\frac{\omega_\mathrm{dd}^2}{\Delta\omega^2}\right)K(t,r)

    *Default:* [*empty*]

    *Example:*

    .. code-block:: matlab

        K = dipolarkernel(t,r,'ExcitationBandwidth',50)     % 50 MHz excitation bandwidth

- ``'OvertoneCoeffs'`` - RIDME overtone coefficients
    1D-Array containing the overtone coefficients for RIDME experimens. If passed, the dipolar kernel overtones are calculated based on the passed coefficients. The coefficient values must be normalized. The kernel containing up to the :math:`k^{th}` overtone is constructed as follows

    .. math:: K(t,r)  = \int_{0}^{1}\sum_{k=1}^K c_k\cos\left[(3\cos^2\theta -1)k\frac{\mu_0\hbar\gamma_A\gamma_B}{4\pi r^3}t\right]\mathrm{d} \cos\theta

    where :math:`c_k` are the overtone coefficients passed as arguments.

    *Default:* [*empty*]

    *Example:*

		.. code-block:: matlab

			K = dipolarkernel(args,'OvertoneCoeffs',[0.4 0.2 0.4])   % fundamental, 1st, and 2nd overtone

- ``'g'`` - Electron g-value
    Specifies the g-value of the electron spin center used to compute the dipolar frequencies from the given distance axis.

    *Default:* free-electron g value

    *Example:*

		.. code-block:: matlab

			K = dipolarkernel(args,'g',2.01)

- ``'Method'`` - Kernel matrix calculation method
    Specifies the method the kernel matrix is computed numerically.

    *   ``'fresnel'`` - Uses Fresnel integrals. This method is fast and accurate.

    *   ``'integral'`` - Uses MATLAB's ``integral()`` function. This method is accurate, but slow.

    *   ``'grid'`` - Uses orientational averaging over a grid of orientations, using the number of orientations given in ``nKnots``. This method is slow, and it converges very slowly with the number of orientations.

    *Default:* ``'fresnel'``

    *Example:*

		.. code-block:: matlab

			K = dipolarkernel(args,'Method','integral')

- ``'nKnots'`` - Number of orientations for orientational averaging
    If the kernel is computed using ``'grid'``, this options specifies the number of orientations between :math:`\theta=0` and :math:`\theta=\pi/2` used for orientational averaging.

    *Default:* ``5001``

    *Example:*

    .. code-block:: matlab

        K = dipolarkernel(args,'Method','grid','nKnots',1e4)
