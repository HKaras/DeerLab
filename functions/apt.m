%
% APT Approximate Pake Transformation of dipolar spectroscopy data
%
%   P = APT(S,K)
%   Computes the distance distribution corresponding to the signal (S)
%   according to the APT kernel (K). The kernel must be a structure as
%   generated by the aptkernel() function.
%
%   P = APT(S,K,DDS)
%   Specify the distance-domain smoothing parameter (DDS) by passing as a 
%   scalar value.
%
%   [P,r] = APT(S,K,DDS)
%   The output distance axis can be requested as a second argument
%

% This file is a part of DeerLab. License is MIT (see LICENSE.md). 
% Copyright(c) 2019: Luis Fabregas, Stefan Stoll, Gunnar Jeschke and other contributors.


function [P,Uniformr] = apt(S,APTkernel,DistDomainSmoothing)


%--------------------------------------------------------------------------
% Parse & Validate Required Input
%--------------------------------------------------------------------------
if ~isa(APTkernel,'struct')
    error('The input APTkernel must be a a valid structure.')
end

if iscolumn(S)
   S = S'; 
end
if ~isreal(S)
    error('Input signal cannot be complex.')
end
validateattributes(S,{'numeric'},{'2d','nonempty'})

if nargin<3 || isempty(DistDomainSmoothing)
    DistDomainSmoothing = 0.05;
else
    validateattributes(DistDomainSmoothing,{'numeric'},{'scalar','nonnegative'})
end

%--------------------------------------------------------------------------
% APT algorithm
%--------------------------------------------------------------------------

%Turn off warnings to avoid ill-conditioned warnings 
warning('off','all')

%Get APT kernel data
K = APTkernel.Base;
NormConstant = APTkernel.NormalizationFactor;
APT_FrequencyAxis = APTkernel.FreqAxis;
APT_t = APTkernel.t;
Crosstalk = APTkernel.Crosstalk;

%Compute frequency distribution
[FreqDimension,~] = size(K);
FreqP = zeros(1,FreqDimension);
for k=1:FreqDimension
    FreqP(k) = FreqP(k)+sum(K(k,:).*S.*APT_t)/NormConstant(k);
end

%Perform crosstalk correction
APTdistribution = Crosstalk\FreqP'; % crosstalk correction, eqn [22]

%Map fequencies to distances
Freq2Dist = zeros(length(APT_FrequencyAxis),1); % initialize distance axis (mapping of dipolar frequencies to distances)
for k = 1:length(Freq2Dist)
    Freq2Dist(k) = (52.04/APT_FrequencyAxis(k))^(1/3);
end
MappedDistances = APT_FrequencyAxis/2; % initialize distance axis (mapping of dipolar frequencies to distances)
for k = 1:length(MappedDistances)
    MappedDistances(k) = (52.04/MappedDistances(k))^(1/3);
end
APTdistribution = interp1(Freq2Dist,APTdistribution,MappedDistances,'pchip',0);
APTdistribution = APTdistribution';

%Perform distance-domain smoothing filtering
FilteredAPTdistribution = zeros(length(APTdistribution),1);
for k = 1:length(APTdistribution)
    DDSfilter = (MappedDistances - MappedDistances(k)*ones(1,length(MappedDistances)))/DistDomainSmoothing;
    DDSfilter = exp(-DDSfilter.*DDSfilter);
    DDSfilter = DDSfilter';
    FilteredAPTdistribution(k) = sum(DDSfilter.*APTdistribution)/sum(DDSfilter);
end

%Normalize integral
for k=1:length(APTdistribution)
    FilteredAPTdistribution(k) = FilteredAPTdistribution(k)/(MappedDistances(k))^4;
end
%Renormalize
FilteredAPTdistribution = FilteredAPTdistribution/max(FilteredAPTdistribution);

%Interpolate to uniform distance axis
Uniformr = linspace(min(MappedDistances),max(MappedDistances),length(S));
P = uniformgrain(MappedDistances,FilteredAPTdistribution,Uniformr);

%Normalize to unity integral
P = P/sum(P)/mean(diff(Uniformr));

%Make the distribution a column
P = P';

%Turn warnings back on
warning('on','all')

end

